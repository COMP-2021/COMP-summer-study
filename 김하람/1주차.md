# 상수 const와 var
const로 선언 -> 수정 불가, 초기화 반드시 : 상수
var -> == let : 변수 저장


# 조건문 if, switch, 조건부 연산자(삼항 연산자)
if (조건식) {
    동작문;
} else if (조건식) {
    동작문;
} else {
    동작문;
}

switch (조건식) {
    case 비교조건식:    // 조건식과 비교조건식이 일치(===) 시
        동작문;
        break;
    default:            // 맨 윗줄에 있어도 상관x
        동작문;
}

(조건식) ? (참일 때 실행되는 식) : (거짓일 때 실행되는 식);


# 반복문 while, for
while (조건식){
    동작문;
}

for (시작; 조건식; 종료식) {        // 시작, 조건식, 종료식 생략 가능
    동작문;
}


# 배열
const arr = [요소1, 요소2, 요소3];

// const로 선언하더라도 객체 내부 수정 가능
arr[0] = 값; -> 가능 / arr = [요소1, 요소2]; -> 불가능

arr.length == 요소 개수

// 배열 요소 추가
arr[arr.length] = 값;     // 배열 맨 뒤 인덱스에 요소 추가
arr.push(값);         //  배열 맨 뒤 인덱스에 요소 추가
arr.unshift(값);         //  배열 맨 앞 인덱스에 요소 추가

// 배열 요소 삭제
arr.pop(); // 배열 맨 뒤 인덱스 요소 삭제
arr.shift(); // 배열 맨 앞 인덱스 요소 삭제

arr.splice(인덱스); // 인덱스 요소부터 끝 요소까지 삭제
arr.splice(지우고 싶은 요소 인덱스, 기준 인덱스로부터 지울 요소 개수);   // 배열 중간 인덱스 요소 삭제
arr.splice(지우고 싶은 요소 인덱스, 기준 인덱스로부터 지울 요소 개수,
            지운 자리에 채울 값1, 값2, ...);

// 배열 요소 찾기
arr.includes(값);   // true, false 반환
arr.indexOf(값);    // 앞에서부터 탐색하여 값의 인덱스 반환, 없으면 -1 반환
arr.lastIndexOf(값); // 뒤에서부터 탐색하여 값의 인덱스 반환


# 함수
function() {} OR () => {}

ex)
function a() {}                // 함수 선언문 (if for처럼 ;을 붙이지 않음. 붙여도 됨)
const b = function() {};       // 함수 표현식
const c = () => {};            // 화살표 함수 

a();    // 함수 호출
return 반환값;  // 함수 호출 시 반환 값, 함수를 종료하는 기능, 반환 값은 1개

// 인수와 매개변수
function a(parameter) {
    console.log(parameter);
}
a('argument');
-> 매개변수와 인수의 개수가 일치하지 않아도 되는데, 일치하지 않은 매개변수는 undefined로 처리,
    함수 내에서는(화살표 함수 제외) arguments 라는 키워드로써 매개변수를 배열 형태로 접근 가능,
    (인수 개수) > (매개변수 개수)일 경우 초과한 인수들은 무시됨,
    화살표 함수에서 중괄호{}에 이어 return문이 나오면 둘은 생략 가능


# 객체
// 객체 리터럴
const 객체명 = {
    속성1이름: 속성값,
    속성2이름: 속성값,
    속성3이름: 속성값,      
};                  // {}를 사용해 객체를 표현 : 객체 리터럴
-> 마지막 속성값 뒤에 ,가 없어도 되지만 다음 속성 추가 시 쉼표를 추가 해야함,
    속성명이 문자열이어도 따옴표를 사용하지 않아도 되지만 whitespace, 특수문자 사용 시 사용 필요,
    없는 속성에 접근 시 undefined

객체명.속성;  ==  객체명['속성'];   // 객체 리터럴 속성 접근
객체명.속성 = 새로운 값;            // 속성 값 수정
delete 객체명.속성;                 // 속성 제거, 제거된 속성 값은 undefined

+) 배열과 함수가 객체인 이유
: 배열과 함수에도 속성들을 추가 수정 제가 가능
function a() {}
a.first = '1';
const arr = [];
arr.second = '2';
console.log(a.first);       // 1
console.log(arr.second);    // 2

// 메서드
const 객체명 = {
    메서드명: function(){
        동작문;
    },
};
객체명.메서드명();

// 객체 비교
객체가 아닌 숫자, 문자열, 불 값, null, undefined는 서로 비교(===)하면 모두 true를 반환
but, 객체 배열 함수는 비교하면 false 반환
따라서 같은 객체인지 비교하고 싶다면 기존 객체를 변수에 저장해 두어야 함
